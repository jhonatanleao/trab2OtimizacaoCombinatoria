Foi criado duas struct uma para a solução com um vetor para salvar as atividades alocadas um para FO e outro para qtd de atividades que foram alocadas na máquina e com essa struct foi criado um vetor do tamanho da quantidade de máquinas usadas.
A segunda struct criada foi para salvar as tarefas, nessa struct possui variáveis para salvar o custo, quantidade de predecessor e quantidade de sucessor e possui dois vetores um para salvar os predecessores e um para salvar os sucessores. Segui a lógica anterior de criar um vetor com essa struct com o tamanho da quantidade de atividades que o problema possui.
A para os critérios da heurística gulosa foi: todas as atividades que não tem predecessores são alocados nas primeiras máquinas, a divisão quantidade de atividades por quantidade de maquina define a quantidade de atividades cada máquina vai ter e o resto fica na última máquina, para o critério de escolha foi a que possui a maior FO e em caso de empate, escolhe a que está mais no começo do vetor de atividades candidatas.
Para gerar as vizinhas foi usada a seguinte lógica: escolhe dois números aleatórios distintos (maquina1 e maquina2) dentro da quantidade de máquinas que a instância possui e escolhe um número aleatório dentro da quantidade de atividades alocadas a primeira máquina tem e coloca no final do vetor de atividades da segunda máquina obedecendo as regras do problema.
Porém não consegui gerar novas soluções com FO melhores que a FO da solução criada pela heurística gulosa.
